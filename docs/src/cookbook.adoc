= icon:cutlery[] Brine Cookbook
Matt Whipple <http://github.com/mwhipple[@mwhipple]>
:description: Cookbook for the Brine REST Testing DSL
:keywords: Brine, Cucumber, REST, DSL
:gh_repo: https://github.com/brightcove/brine

== Overview

The following are some recipes to address issues which may arise while using
Brine but are not considered part of Brine's (current) responsibility.
Many of these are focused on simplicity and ease rather than robustness or
elegance, and modification to address specific cases should be expected.

Many of these will also be platform specific and be subject to further
organization once platforms beyond ruby are supported.

== Intercepting of HTTP Calls

=== Context

There may be cases where the request or reponse may need to be modified
in some way before or after transmission, for example to add a custom header
which is somehow specific to the testing configuration and therefore outside
of anything that belongs in the specification.

=== Solution

This can be done through the registration of custom Faraday middleware on
the Brine client. All of the registered middleware attaches
to the generated connection through an array of functions in
{gh_repo}/blob/master/lib/brine/requester.rb[requester.rb].
Each function accepts the connection object as its single parameter.
The array of functions is exposed as `connection_handlers` and can be modified
through getting that property from either the default `World`
(for the default client) or from an appropriate `ClientBuilder`
if creating custom clients and mutating it accordingly (setting the reference
is not suported).
You could just build your own client without the facilities provided by Brine.

=== Recipe

An example to add a custom header could be implemented as follows:

[source,ruby]
----
require 'faraday'
class CustomHeaderAdder < Faraday::Middleware
  def initialize(app, key, val)
    super(app)
    @key = key
    @val = val
  end

  def call(env)
    env[:request_headers].merge!({@key => @val})
    @app.call(env)
  end
end

...

connection_handlers.unshift(proc do |conn|
  conn.use CustomHeaderAdder, 'x-header', 'I am a test'
end)
----

== "Assurances"

=== Context

Ideally all tests should be as self-contained and isolated as possible;
when writing functional tests, however, there are cases where this isn't
feasible or possible. In some cases a system depends on another external
system which is not a system that is under test and which (for whatever reason)
cannot be easily worked with. In white box testing such a system would likely be
represented by some form of test double, but this may be unfeasible and/or
undesirable when testing a deployed system.

An example of such a system is user/account management which often incurs
additional overhead to provision a new account. When testing a secured
system valid accounts are needed for representative testing, but provisioning
a new account may be difficult or outside the scope of the system that is being
actively tested. If tested functionality involves enacting account-wide changes
and the number of accounts is limited, then that is likely to unfortunately
prevent complete test isolation.

=== Solution

In such cases a standard solution is to designate certain resources to be
reused for certain tests. These are analogous to the concept of "fixtures" in
some test suites though there may be slight differences in implementation and
reliance on them. Here the term "assurances" is used...primarily because it
starts with `a` which lends itself to relevant files being listed towards the
beginning alphabetically in a given directory.

The goal of assurances is to specify conditions which are expected before other
tests are to be run. Preferably the dependent tests should also explicitly
declare the dependency but a significant solution for that is not established.
Assurances therefore validate that preconditions are met; ideally if such
preconditions can be established idempotently then the assurances can do so
before the validation.

==== Assurances are NOT Tests

**Assurances validate a state which is desired to be consistently retained
within the system rather than being changed**. This means that they should _not_
be used for tests as that would require state changes, nor should they clean up
after themselves (as that would also imply a state change). If assurances are
configured for a system which should also be tested, then appropriate tests
should exist (including those that may validate any behavior relied upon by
the assurance).

==== Consequences

As mentioned previously assertions help in cases where tests cannot be fully
isolated, and therefore some known state must be established and reused across
tests (and such state should *not* change). A practical reason for this is to
allow for overlapping test executions.
If tests are not fully isolated, state is being changed, and test runs overlap,
then tests may fail non-deterministically due to one test run pulling the state
out from another. This in the simplest form can be a nuisance but it also
effectively precludes the ability to speed up test runs through the use of
parallelism/asynchronicity.

_TODO: Enumerate drawbacks_

=== Recipe

This can be done using standard cucumber tags. Assurances can be defined in
designated `assure_*.feature` files where each Feature is appropriately tagged:

[source,gherkin]
----
@assure
Feature: Some preconditions are verified...
----

And then a Rake task is added to run those tagged features:

[source,ruby]
----
Cucumber::Rake::Task.new(:assure) do |t|
   t.cucumber_opts = "#{ENV['CUCUMBER_OPTS']} --tags @assure"
end
----

The Rake task that runs the other tests then depends on that task:

[source,ruby]
----
task :invoke_cuke => [:assure] do
  #Run cucumber, potentially in parallel and likely with --tags `@assure`
end
----

This approach tests preconditions and will avoid running the rest of the tests
if they are not (relying on standard Rake behavior). The assurances can also be
run with different Cucumber behavior so that the full test suite can be more
stochastic (randomized/non-serialized) while the assurances can be more
controlled.
